---
title: "Clustering avec DBSCAN"
author: "FX Jollois"
date: "11 mars 2022"
output: 
  xaringan::moon_reader
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(dplyr)
n = 1000
data1 = tibble(exemple = 1, z = rbinom(n, 1, .5)) %>%
  mutate(x = rnorm(n, ifelse(z == 1, 1, 3), sd = 0.5), 
         y = rnorm(n, ifelse(z == 1, 1, 3), sd = 0.5))
# plot(data1[,c("x", "y")])

data2 = tibble(exemple = 2, z = rbinom(n, 1, .5)) %>%
  mutate(r = ifelse(z == 1, 0.5, 1.5), t = runif(n, 0, 2*pi)) %>%
  cbind(useful::pol2cart(.$r, .$t)[,c("x", "y")]) %>%
  select(-r, -t) %>%
  mutate(x = x + 2 + rnorm(n, sd = 0.2),
         y = y + 2 + rnorm(n, sd = 0.2))
# plot(data2[,c("x","y")])
```


# Introduction

Méthode classique de clustering : $k$-means

1. Association d'un point à la classe la plus proche
2. Calcul des nouveaux centres
3. Itération des étapes 1 et 2 jusqu'à convergence

**MAIS**

- Nombre de classes à définir en amont
- Tous les individus sont obligatoirement affectés à une classe, même les outliers
- Forme des classes devant être sphérique

---

# Exemples

2 exemples : 1 très classique et 1 plus difficile

```{r exemples, fig.align='center', fig.width=10}
library(ggplot2)
ggplot(rbind(data1,data2), aes(x, y, color = factor(z))) +
  geom_point() +
  facet_grid(. ~ exemple, labeller = label_both) +
  theme_minimal() +
  labs(color = "Classe")
```


---

## DBSCAN

> Density-based spatial clustering of applications with noise

- Basé sur la notion de densité
- Une classe est définie sur l'*accessibilité* de la densité
  - Un individu est directement accessible à un autre individu si la distance entre les deux est plus petite qu'un seuil défini en amont
  - 2 individus sont accessible entre eux s'il existe une chaîne de points directement accessible 2 à 2 entre les deux
  - Une classe est composée d'individus accessibles entre eux
- Algorithme
  - Pour chaque nouvel individu, on cherche les individus accessible directement
  - S'il y en a un dans une classe, on affecte ce nouveau point à la classe
  - A la fin, les classes avec peu d'individus ne sont pas conservées
- On obtient donc un ensemble de classes et un ensemble d'outliers (individus dans aucune classe)
- Deux paramètres sont à déterminer :
  - Seuil minimal de distance pour considéré deux points comme accessible
  - Nombre minimal d'objets dans une classe
  